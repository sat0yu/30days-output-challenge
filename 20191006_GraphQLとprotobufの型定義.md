本文では、現在参画しているプロジェクトのサービスアーキテクチャに関して、今の時点での考えを書き残しておこうと思う。半年後あたりに振り返ることができたら嬉しく思う。

本プロジェクトのシステムは以下ように構成されている。
- フロントエンド: iOSネイティブアプリ
- サーバーサイド: GraphQL, gRPCサーバ群

本文ではサーバーサイドの構成に注目して記録しておきたい。
というのも、じつはGraphQLスキーマとgRPCスキーマ（正確にはprotobuf）の重複問題がチーム内で話題にあがること多いからだ。筆者もまだ明確な持論を持てていない。

仮説として「WebAPIをGraphQLで提供するならマイクロサービス間通信もGraphQLにすべきだ」という主張がある。
gRPCサーバーから返されるレスポンスオブジェクトをGraphQLスキーマ定義に合わせて変換する手間が無視できないという点が、主張を支える主な理由だ。
変換の手間は実装言語（ちなみに本プロジェクトではGraphQL実装にRubyを利用）に依る部分もあるかと思う。
しかし、変換処理そのものよりも、変換の前後で似たような”型の定義”が重複することが好ましいとは言えない。

ではなぜ、型定義が重複することが受け入れ難く感じられてしまうのだろうか。

第一に、盲目的に型定義を重複させていると整合性を担保した開発が困難になると考えられる。
たとえば、変換元の（gRPC）サービスで何らかの変更（例えばあるフィールドの削除）が発生した場合は、変換先の（GraphQL）サービスも同時に変更を反映しなければ整合性が保てない。
一言で表現するならば、（盲目的な）型定義の重複は「サービスの独立性を毀損する」となる。
整合性を保てない変更をすべきでないという主張は一定の理解を集めるだろうが、そもそも整合性を考慮せずに済むならこれに越したことはない。

第二に、本当に型が重複しているなら、そのサービスの責務が適切でない可能性があるという点だ。
GraphQLの型定義は詳細実装（protobufやテーブル定義）従うのではなく、独立して設計されるべきだ。なぜなら、それはフロントエンドのためのサービス（API）を提供するからだ。
画面べったりの過度に最適化した設計が適切ではないことは明らかだが、とはいえ基本的にはフロントエンドに対して便利な形でスキーマを設計するべきだ。
フロントエンドとの間で「ドメインモデルは何か」に関して合意を形成し、これに基づいてスキーマ設計がなされることが望ましい。

だが、ここでよく考えてもらいたい。２つ目の理由「サービスの責務が適切でない」という点は、スキーマ定義言語に何を使うかとは関係なく、それ自体で解決されるべき問題ではないだろうか。
フロントエンドに対する純粋な関心に基づいて設計されたGraphQLスキーマであれば、そもそも型定義が詳細実装と一致することは多くないはずだ。
そして型定義が重複しないのであれば、当初の主張「WebAPIとマイクロサービス間通信の型定義を共通化」を支えていた理由が危うくなる。
むしろ、重複問題に対して間違った解決策を講じることで状況が悪化してしまうのではないかと危惧している。

しかし、冒頭に述べたとおり、筆者はまだ以上の議論に自信を持って何かを主張するに至っていない。
「そもそも型定義は重複するべきではない」とは述べたものの、GraphQLのもつ柔軟な表現力をもってすれば、サービスの責務すら固定化する必要がないのかもしれない。
