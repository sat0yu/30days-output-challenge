昨日は、RDBにおいて木構造を表現する最も素朴な方法のひとつである「隣接リスト」を確認した。
今回は表現方法に少し工夫を加えた「閉包テーブル」をみていきたい。

隣接リストでは構造情報と節点情報をひとつの行で表現した。
一方、閉包テーブルでは構造情報と節点情報を分けて持つことが基本となる。

ここでは節点情報の例として以下のテーブルを想定しておく。

| --- | ------ |
| id | name |
| 1  | A       |
| 2  | B       |
| 3  | C       |
| 4  | D       |

閉包テーブルにおいて、構造情報は「節点のすべての関係をそれぞれ行としてもつ」ことで表現される。
すなわち、各行は(1)ancestor_id, (2)descendant_id, (3)path_lengthの３つ組で表現される。
ただし、各節点はpath_length = 0として自分自身との関係を表現する行をもつことに注意されたい。

- ancestor_id: 根に近い節点のid
- descendant_id: 葉に近い節点のid
- path_length: ancestorとdescendantをつなぐパスの長さ

例えば以下の例ではAが根で、Bが節、CとDが葉に相当する。
(CはBを介してAにぶら下がっており、DはAに直接親子関係をもつ)

| ---------------- | ------------------- | ---------------- |
| ancestor_id | descendant_id | path_length |
| 1                  | 1                      |  0                 |
| 1                  | 2                      |  1                 |
| 1                  | 3                      |  2                 |
| 1                  | 4                      |  1                 |
| 2                  | 2                      |  0                 |
| 2                  | 3                      |  1                 |
| 3                  | 3                      |  0                 |
| 4                  | 4                      |  0                 |

それでは次に、閉包テーブルにおけるデータの操作性を確認していく。
はじめに「特定の節点の子孫一覧の取得」というタスクを考えてみよう。
これは、隣接リストではJOIN操作の回数が定まらず取り扱いが難しかったタスクだ。

じつは閉包テーブルを用いた場合、このタスクはancestor_idを指定してSELECTするだけで達成できる。
表現方法を変えるだけで同じタスクがいとも簡単に解決できてしまうのだ。

e.g. Bのすべての子孫の節点名を取得
SELECT n.name
FROM nodes as n INNER JOIN structure as s ON e.id = s.descendant_id
WHERE s.ancestor_id = 2;

さらに、直接の子だけを取得したければ、先程のクエリにpath_length = 1の条件を追加するだけで済む。
また、逆に親・祖先を引く場合にはdescedantを指定することで同様にして目的を達成できる。

変更（節点の追加・移動）操作の場合はどうだろうか。
節点を追加する際には、そこから到達できるすべての子孫・祖先との関係性を定義する情報を新たに書き込む必要がある。
節点を移す場合には、自身のidをancestorかdescendantにもつ行をすべて削除し、その後素直に追加操作を実行すればよい。

これらの変更操作を１つのクエリだけで済ませるのは困難である。
アプリケーション側で変更すべき情報を整理してから書き込むほうがシンプルになるだろう。

ここまで見てきた限り、閉包テーブルの目立った難点は変更操作の複雑性ぐらいに思える。
閉包テーブルは隣接リストよりも優れた表現方法だと言えるのだろうか？

じつはまだ忘れてはならない観点が残っている。
それは、閉包テーブル表現にはデータの正当性（データが正しい木構造を表現する）を保証する仕組みがないことだ。

例えば、閉包テーブルでは複数の親を持つような構造（もはや木構造ではない）も表現できてしまう。
隣接リストの表現力では発生しえなかった問題が、閉包テーブルでは新たに出現する。
これらデータ上の不具合に対しても、アプリケーション側で適当に対処するための実装が必要となる。

以上、簡単に閉包テーブルに紹介した。
明日は「入れ子集合」について議論しようと思う。
入れ子集合表現では、木構造そのものを表現することをせず、木構造に対応する入れ子構造を表現する。
隣接リスト・閉包テーブルのときと同様に、利点・難点をみていこう。
