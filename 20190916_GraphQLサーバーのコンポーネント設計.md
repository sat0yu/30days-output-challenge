GraphQLを用いてサービス設計をする場合、QraphQLサーバーに負わせる責務を少なくし、複雑な処理は下流のサービスに移譲する方針が望ましいという。
適切なコンテストに基づいて分割され凝集度を十分に高めたサービス群があるならば、この主張に反論の余地はないだろう。
しかし実際のところは、いくらマイクロサービスの普及が進んだとは言え、そのような望ましい状況は少ないように思える。
むしろ、他サービスに依存しない単体のGraphQLサーバーを開発していたり、どうしてもGraphQLサーバー全体としての責務を軽くすることが困難な場合が多いのではないだろうか。

本文では、GraphQLサーバーがその責務範囲を狭めることが難しい状況において、いかにしてコードを構造化し見通しの良い設計を行うかを考えたい。

RailsやDjangoといったMVCパターンを採用している素朴なWebフレームワークは、各コンポーネントの責務範囲を分かりやすい形で説明する。
フレームワークのお作法に正しく従って開発をする限り、ある処理をどのコンポーネントに書くべきか迷うことはそう多くないだろう。

一方で、GraphQLのようにまだ一般に利用事例が多くない技術の場合、コードを書きながら設計に関して悩むことが多い。
例えばGraphQLのRuby実装のひとつであるgraphql-rubyの場合、気がづくとGraphQL Schema(type)定義ファイルが各フィールド値の取得・計算処理によって肥大化していたりする。

GraphQLの文脈では一般に「（各フィールド値の）取得・計算処理」を「Resolveする」と表現し、これらを解決する責務を負ったコード（コンポーネント）はResolverと呼ばれる。
先にあげたSchemaの肥大化はResolverを適切に分離できていないことが原因だ。

また、Jonas Helfer氏によればResolverにすべての責務を押し込むのではなく、さらにModelとConnectorへと責務を分割することが望ましいとされる。
これにより、共通して繰り返し利用される処理（Connector）とドメインに依存したオブジェクト定義や処理（Model）を切り分けて管理することができるからだ。
ref. https://blog.apollographql.com/how-to-build-graphql-servers-87587591ded5

また、GraphQLではN+1問題がよく引き合いに出される。
必要となるデータがクエリに依存して変化するため、複数テーブルをJOINしてデータを取得したり、同一テーブルへのSELECT文をまとめて発行したりといった自明な解決手法は利用しづらい。
そのため、GraphQLではgraphql-batchやDataLoaderのような、遅延評価を利用してN+1問題の解決を図るライブラリに頼ることなる。
やがてLoadersのようなコンポーネントが生まれ、N+1を解決するための複雑なコードが次々と押し込まれていく。

ここで今一度Modelの責務を考えておこう。
先の議論で、Modelには「ドメインに依存した処理」という非常に大雑把な責務範囲が与えられていた。
当面は現状のコンポーネント定義でも十分に機能するだろう。
しかし、複数のデータソース（DB、キャッシュ、下流サービス）を利用したい場合はどうだろうか。
さらにModelはResolverやLoaderから直接利用されるコンポーネントということもあり、利用側から要求された責務・処理がすぐに増加することも予想できる。

そこで、Model自体はPOROとして定義しておき、データソースからmodelを生成する責務をRepositoryに分けることを提案したい。
すなわち、クリーンアーキテクチャの文脈でドメインモデルやドメインロジックと呼ばれる責務をModelに任せ、データの取得とModelの生成はRepositoryを介して行うのである。
この方針も用いれば、例えば当初DBから取得していたデータを負荷増加に伴ってキャッシュに移す必要が生まれた場合にも、変更はRepositoryに手を加えるだけで済む。
おまけにRepositoryをモックすることでResolverやLoaderのテストも書きやすくなる。

じつは筆者も現在、GraphQLを要素技術として採用したプロジェクトに携わっている。
まさに「GraphQLサーバーがその責務範囲を狭めることが難しい状況」なわけだが、チームにGraphQLの知見が十分に蓄積されておらず、今もなおコンポーネント設計は試行錯誤の最中にある。
残念ながら本文で提案したコンポーネント設計はまだ上記プロジェクトでも実践できていないのだが、また新たに知見が得られれば続編を記したいと思う。
