我々が住む世界には木構造をもつ事象が多く見られる。例えば住所は根（国）から節（県）に分かれ、やがて葉（番地）に到達する木構造として表現できる。

では、このような木構造を伴う情報を永続化してアプリケーションで取り扱う場合には、どういった選択肢が考えられるだろうか。
本文ではとくに、現在最も広く用いられているリレーショナルデータベース（以下RDB）において木構造を表現する方法として以下の３つを紹介する。

- (a) 隣接リスト
- (b) 閉包テーブル
- (c) 入れ子集合

一般に木構造をデータベースに格納する場合は、１対他の繰り返し構造を素直に格納できるドキュメント型DBや、あるいは構造そのものを自然に表現できるグラフデータベースが便利だと考えられる。
これらのパラダイムをもつデータベースは簡潔な形でデータの入出力が可能である。
例えばドキュメント型DBでは、木構造をjsonで表現しそのまま格納することができるため、根ノードの情報だけを用いて、その配下に広がる木構造を一度に取得できる。

一方で、RDBは木構造を表現するために工夫が必要だ。
対象情報を行列で表現することを前提とするRDBでは、木構造を素直に表現することができないからだ。

真っ先に思いつく方法として、「隣接リスト」がある。
隣接リストでは１行がノード（根・節・葉）に対応し、それぞれ(1)識別子、(2)親識別子、(3)その他の属性をカラムにもつ。
例えば以下ではAが根で、Bが節、CとDが葉に相当する。

| --- | ------------ | ------- |
| id | parent_id | name |
| 1 | null           | A        |
| 2 | 1               | B       |
| 3 | 2               | C       |
| 4 | 1               | D       |

隣接リストは行列表現において木構造を表現する最も素朴な方法のひとつといえる。
節点を一行として表現する思考はモデリングの作業に違和感なく馴染むだろう。

隣接リストは操作性に関しては、データの入力が非常に直感的に実行できる利点がある。
一方で取り出し操作において隣接リストは難点をもつ。
データ取得に発行するクエリのJOIN回数が木の高さ（＝再帰構造）に依存してしまうのだ。

表現対象のもつ構造において現実的な高さの上限が決まっているならば、高さごとにクエリを用意することである程度の利便性は確保できる。
高さの変化に大きな自由度がある場合には、残念ながら隣接リストの選択は困難を伴う可能性が高い。

以上、隣接リストついて紹介した。
明日は閉包テーブルについて述べようと思う。
閉包テーブルは「節点の関係性」すなわち「構造」を自然に表現することに特化した方法だ。
隣接リストと同様にして、閉包テーブルの利点・難点の両方について見ていきたい。
