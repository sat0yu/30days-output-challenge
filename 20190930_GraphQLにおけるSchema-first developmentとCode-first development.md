GraphQL実装にはSchema-First Development(SFD)とCode-first Development(CFD)の２つのパラダイムがあると、同僚から以下の記事を教わった。
https://www.prisma.io/blog/the-problems-of-schema-first-graphql-development-x1mn4cb0tyl3

本文ではSFDとCFDの違いを説明するとともに、筆者の考えを述べる。

SFDとは、その名の通りGraphQLスキーマを定義することから開発がはじまる。
スキーマは.graphql拡張子のテキストファイルであったり、あるいは小さいものはハードコーディングされたりするようだ。
一度スキーマが作成されると、多くの場合はそこからコードを自動生成する。これはproto bufferとgRPCの関係に相当する。
SFDでは自動生成で得られたコードをもとに具体的なビジネスロジックを実装していく。

このアプローチは静的型付け言語と相性が良い。なぜなら、生成された型定義コードをベースにして開発ができるからだ。
静的型付け言語ならば、先の記事で言及されていたSFDの問題点「スキーマ定義と実装の不一致」も発生しない。
Golangでいえばhttps://github.com/99designs/gqlgenやhttps://github.com/graph-gophersがSFDを採用したライブラリだ。

CFDは最初期のhttps://github.com/graphql/graphql-jsにて採用されたアプローチである。
上記記事によれば一時はSFDが一世を風靡したものの、周辺ツールのメンテナンスコストの懸念から再びCFDが見直されているようだ。

たとえばgraphql-rubyはCFDの最たる例で、rubyの得意とするDSLを活用することで周辺ツールを必要としない機能を提供している。
もはやgraphql-rubyさえあれば、コード自動生成も余計なIDE設定も、スキーマの合成も全て済ませることができる。
エンジニアがgraphqlスキーマ定義を書くことはなく、スキーマ定義もビジネスロジック実装もすべてrubyコードで表現される。

面白いのは、静的型付け言語であるgolangにおいてもCFDのアプローチをとったライブラリが存在していることだ。
https://github.com/graphql-go/graphqlは型情報を捨てる（interface{}を使う）代わりに、スキーマ定義とロジック実装を統合した。

以上、SFDとCFDの違いを簡単にみてきた。
筆者は、静的型付け言語の使用を前提とした場合には、SFDで型情報を利用できるメリットはCFDのそれを凌ぐと考える。
たしかにCFDのアイディアは無駄がなく、思想も非常に魅力的だが、型情報がない限りは何らかの手段でスキーマ定義とロジック実装の整合性を保つ工夫が必要となる。

型情報は各コンポーネントの責務範囲を区切る目的において、さらに重要になる。型情報があればこそ、ドメインオブジェクトを導入し、ResovlerやDataLoader、そしてGraphQL（フレームワーク）で各層の責務を明確にできるからだ。
とくにRubyのような動的型付け言語の場合、コンポーネントの責務範囲に曖昧性を許した場合、容易に手に負えない状況に陥る。ResolverがアドホックにHashを組み立ている様子は想像に難くない。

型情報を捨てずにCFDのアプローチを実践しているGraphQL実装があれば是非とも試してみたい。
しかし軽く調べた範囲では、そのようなgolangのGraphQL実装は見当たらなかった。
