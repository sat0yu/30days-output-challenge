Nullableフィールドの使い方に関する記事
https://blog.apollographql.com/using-nullability-in-graphql-2254f84c4ed7

Nullableという単語からは、何か選択肢を増やす機能を与える印象を受ける。
例えば関数やAPI、あるいはDatabaseスキーマの定義において、特定のフィールド（カラム）の型に対してNullable(Optional)な制約を利用する場面がある。
このような状況は、一見すると、Nullableの設定が意思決定を遅延するための妥当な判断のように思える。

しかし「ひとまずNullable」を指定する判断は、意思決定の遅延という目的においてはたして本当に正しい選択なのだろうか。
本記事ではアプリケーションの「進化性」の観点からNullableをいかに扱うべきかという問いに対するひとつの解を示している。

進化性とは、対象物の経時的な変化に対する性質を述べている。
つまり、進化性の観点から先ほどのデータベーススキーマを考えるとき、例えば我々は「当初はNullableに設定していたカラムが非Nullableに変化する場合」や、またはその逆の状況において発生しうる問題に関心をもつ。

さて、実際に「当初はNullableに設定していたカラムが非Nullableに変化する場合」を考えてみる。
結論から述べると、この状況では「ひとまずnullable」に設定する意思決定はうまく働く。なぜならnullableなフィールドを持つデータは出力時の処理において前方互換性を持つからだ。
すなわち、nullableなフィールドを前提として書かれたアプリケーションコードは値のNull検証を含んでいるはずで、当然ながらそのコードは非nullableに変わったあとも正しく動作する。

では、関数のある引数に対して「ひとまずnullable(optional)」を設定した場合をどうだろうか。
じつはこの場合、すなわちnullableな引数を非nullableにする操作は破壊的な変更となる。
その理由は先ほどの真逆であり、nullableな入力は前方互換性を持たないからである。つまり、関数がnullを受け付けなくなるに伴い、その関数を使う側でnull検証が要求される。

さらに議論を進めて、「非NullableがNullableに変化する場合」を考えてみるとこちらも先ほどの逆の結果を得る。
すなわち、入力処理は互換性をもち「ひとまずNullable」がうまく働く一方で、出力処理は破壊的変更となるのである。

以上の議論から、「ひとまずNullable」という意思決定は少なくとも万能でないことは明らかである。
意思決定を遅延し選択肢を残しているように見えても、実際には選択肢を減らす（＝互換性のない）選択を行っているのである。

本文では進化性の観点から、Nullable制約と互換性の関係を見てきた。
しかしながら、進化性とは別の視点から考えてみると、また異なる解が得られる可能性がある。
例えば「Nullableと空文字列をいかに使い分けるか」を考えるとき、進化性の観点はあまり大きな意味をもたない。
むしろ、フィールドの値に対する意味付けといった観点から考えてみることが必要ではないだろうか。

明日につづく
