筆者は半年ほどまえから、業務でGraphQLサーバーを開発・運用しているチームに参画している。
Railsにgraphql-rubyを載せて、下流のgRPCサーバー群を経由してデータベースからデータを取得している。

本文では、半年間のGraphQLサーバー運用経験から得た気づきを残そうと思う。
なお、本文で用いたコードはすべてこちらにまとまっている。
https://github.com/sat0yu/graphql-with-dry-rb

さて、まずはこれまでの変化について述べたい。
当初、本GraphQLサーバはBackend-for-frontent(BFF)として開発されており、おもにgRPCサーバーから返ってきたレスポンスをそのままクライアントに渡していた。
すなわち、*.protoから生成されるメッセージクラスオブジェクトをGraphQLにそのまま渡してレンダリングしていたのだ。
はじめのうちこそ、この方針はうまく動作していた。
本サーバーはほとんどのロジックを持たないサービス設計をしていたため、gRPCサーバーからの値をそのまま返すだけで事足りるケースがほとんどだった。
GraphQLのType定義のほとんどが*.protoファイルの内容と重複していたが、処理途中でオブジェクトに操作を加えないため問題はおきなかった。
しかし徐々にGraphQLサーバーにロジックが集まるにつれて、明らかに開発難易度があがってきた。
Type定義と*.protoファイルの差異が広がってきたのである。

オブジェクトが操作されない前提に立てばこそ、（気持ち悪さは認めるものの）酷似した２種類のインタフェース定義の存在を許容できていた。
しかし一度その前提が崩れると、事態は混乱を極める。
APIとしての責務を果たすためにGraphQLのType定義に基づく契約を守ろうとするが、宣言されている個々のフィールドはいったいどのオブジェクトから取得するのだろうか。
とくに、型の存在しないRubyでこういったインテグレーション処理を記述する難易度は非常に高い。

出力インタフェース（GraphQLのType定義）を満たすために外部入力（gRPCメッセージオブジェクト）に依存してはいけない。
さもなくば出力の変化が入力へ、あるいは入力の変化が出力へ、お互いに影響しあう状況が生まれてしまう。
理想的には、何か安定度の高い概念を導入し、出力も入力も依存の方向を安定度の高い方向と一致させることが重要だ。
これによって入出力の分離度を高めることができる。

さて、前置きが長くなったが、ここからコードを交えて具体的な説明を加えていく。
サンプルコードでは、前文であげた「何か安定度の高い概念」としてdry-rbを用いてサンプルGraphQLサーバーを実装してみた。
すなわち、dry-structを用いて”ドメインモデル”を構築した。
https://github.com/sat0yu/graphql-with-dry-
ドメインモデルオブジェクトは、Repositoryコンポーネントを経由して生成される。
ActiveRecordとは異なり、ドメインオブジェクト自身がデータをFetchするような操作を行ってはならない点に注意されたい。

サンプルコードを見ると、似たようなモデル・Type定義が記述してあり、無駄が多い様に見えるかもしれない。
しかしこれは全く異なる意味をもつ
- Model::Hogeは最も安定度の高いコンポーネント
- SampleGraphQLはRepository, Modelにのみ依存し、gRPCを関知しない
https://github.com/sat0yu/graphql-with-dry-rb/blob/master/graphql.rb
これによって、各サービスの独立性が保たれるだろう。
