前回は「あいまい検索」のタスクと、その実装の一手段としてLocality Sensitive Hashing（以下、LSH）を学んだ。
本文ではより具体的な議論に踏み込み、自然言語処理の分野で古くから用いられるMinHashアルゴリズムにふれたあと、実際にMinHashアルゴリズムを用いたあいまい検索の実装を行う。

なお、本文で実装する類似文字列検索のコードは以下のURLから手に入る。
https://gist.github.com/sat0yu/895e28cce3f42dd980eeb8ea4666319f

まずはMinHashアルゴリズム（以下、MinHash）とは何かを説明する。
MinHash自体は非常にシンプルで、「入力として適当なハッシュ関数h: R -> Rと、ベクトルv=(v_1, …, v_d)を受け取り、出力としてmin{h(v_i} | i = 1, ..., d }を返す」操作を指す。
このときハッシュ関数hはLSHである必要はなく、むしろ分布が偏らない性質を備えていることが望ましい。
紛らわしいが、逆にMinHashで得られた値はLSHとして利用できる。つまり、類似するベクトルはその成分の最小値をとる操作を行っても似たような値をもつ。

MinHashにおいて最も重要な洞察は、むしろMinHashの出力をJaccard係数の近似として用いることができるという事実の方だ。
（Jaccard係数とは集合の類似度を表す指標でJaccard(A, B) = |A ∩ B| / |A ∪ B|で得られる）
どうしてJaccard係数の近似となるのかという議論に関してはPFI岡野原さんの記事が詳しいので参照されたい。
ref. https://research.preferred.jp/2011/02/minhash/

近似値の評価については後述するが、ここではまず「文字列として与えられる検索対象をベクトルに変換するか」を述べておく。
文字列のベクトル表現にはさまざまな種類がある。素朴なものとしてn-gramやbag of words、あるいは機械学習技術によって意味論まで考慮に入れたベクトル表現も登場した。
本文では最も素朴な表現であるbag of words（以下、BoW）表現をもちいる。
BoW表現は「集合に含まれる要素を列挙した表現」と捉えることができ、Jaccad係数による類似度を計算するにも都合が良い。
reg. https://en.wikipedia.org/wiki/Bag-of-words_model

本文では検索対象の単位として英単語を想定しているため、BoW表現のインデックスとしては英文字[a-z]に相当する26次元の2値ベクトルを考える。

e.g. apple, lemon, orangeのBoW表現
[apple] v: [1 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0]
[lemon] v: [0 0 0 0 1 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0]
[orange] v: [1 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0]

さて、MinHashはあくまでJaccard係数の近似を与えるにすぎないという点に注意されたい。
近似を真の値に近づけるためには複数のMinHashを用意し、それらの出力を統合して評価する必要がある。
そして複数のMinHashを得るには、MinHashのもう一つの入力である”任意のハッシュ関数h”も複数必要になる。
それでは、複数の”任意のハッシュ関数h”は一体どのようして用意すればよいだろうか。

この問いの答えは、ハッシュ関数hの使われ方を考えると自然に見えてくる。
ハッシュ関数hはMinHashの中でベクトルv=(v_1, …, v_d)の各要素v_iに適用され、それぞれを不偏な他の値に変換することが期待される。
この要件を達成するには、入力と同じ次元を持ったランダムなベクトルr=(r_1, …, r_d)を生成し、v_iに対して同じインデックスの値r_iを返すだけで十分である。
プログラマはハッシュ関数というとMD5やSHA256のような高級な関数をイメージしがちだが、ここで言うハッシュ関数hはごく限られた範囲の入力を不偏な値に変換するだけで十分だ。

ここで一度、上記の議論をまとめよう。
今回解こうとしているタスクは「検索対象T[i]と検索パターンPを与えられたとき、TからPに似た文字列を得る」ことだ。
タスクの解決策としてはLSH（MinHash）を考える。
文字列のベクトル変換にはBoW表現を用い、文字列の類似度にはJaccard係数の近似を用いる。
Jaccard係数の近似は、N個のハッシュ関数を用意し”MinHash値の衝突回数”を数え上げることで得られる。
またこの際、N個のハッシュ関数はランダムな値をもったベクトルをN個生成して得る。

今回は本手法を実際にgolangを用いて実装した。
作成したgoプログラムは以下URLからアクセスできる。興味のある方は参照されたい。
https://gist.github.com/sat0yu/895e28cce3f42dd980eeb8ea4666319f

以下に実行結果を記す。

Enter query: raspberry
query: raspberry, v: [1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 3 1 0 0 0 0 0 1 0]

[apple] v: [1 0 0 0 1 0 0 0 0 0 0 1 0 0 0 2 0 0 0 0 0 0 0 0 0 0]
[pineapple] v: [1 0 0 0 2 0 0 0 1 0 0 1 0 1 0 3 0 0 0 0 0 0 0 0 0 0]
[orange] v: [1 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0]
[lemon] v: [0 0 0 0 1 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0]
[grape] v: [1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0]
[cherry] v: [0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 1 0]
[strawberry] v: [1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 3 1 1 0 0 1 0 1 0]
[banana] v: [3 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0]
[peach] v: [1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0]

[apple] score: 33
[pineapple] score: 24
[orange] score: 34
[lemon] score: 9
[grape] score: 51
[cherry] score: 39
[strawberry] score: 72
[banana] score: 23
[peach] score: 28

検索対象としていくつかのフルーツの名前を用意しておき、パターンとして”raspberry”を与えた。
ハッシュ関数はN=100個用意し、scoreはMinHashの衝突回数をそのまま表示している。

検索結果をみると、”raspberry”と同じく”berry”を接尾辞としてもつ” strawberry”が最も高いscoreを記録した。
逆に構成文字として”e”のみを共有する”lemon”は最も低いスコアとなっている。

以上、MinHashアルゴリズムの説明とその実装例をみてきた。
本文では一貫して単語を検索対象としていたが、MinHashはむしろ文章の類似度推定に用いられることが多い。
その場合にはBoW表現のインデックスに単語を用いることに注意されたい。
